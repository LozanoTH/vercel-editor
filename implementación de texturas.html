<!DOCTYPE html>  
<html lang="es">  
<head>  
  <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Escena natural optimizada</title>  
  <style>  
    html, body {  
      margin: 0;  
      height: 100%;  
      overflow: hidden;  
      background: #aee1f9;  
    }  
    #canvas3d {  
      width: 100%;  
      height: 100%;  
      display: block;  
    }  
    video, canvas.salida {  
      position: fixed;  
      bottom: 15px;  
      right: 15px;  
      width: 160px;  
      height: 120px;  
      border-radius: 8px;  
      object-fit: cover;  
      opacity: 0.5;  
      border: 1px solid rgba(0,0,0,0.1);  
    }  
    canvas.salida {  
      z-index: 2;  
    }  
  </style>  
</head>  
<body>  
  <canvas id="canvas3d"></canvas>  
  <video id="vista" autoplay playsinline muted></video>  
  <canvas class="salida"></canvas>  

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>  

  <script>  
    const video = document.getElementById('vista');  
    const canvas = document.querySelector('.salida');  
    const ctx = canvas.getContext('2d');  

    var escena, camara3d, renderizador, cubo;  
    var objetivoX = 0, objetivoY = 0, objetivoZoom = 5;  
    var suavizadoX = 0, suavizadoY = 0, suavizadoZoom = 5;  
    var manoIzquierdaPrev = null;  

    function iniciarEscena() {  
      escena = new THREE.Scene();  

      // Fondo 360  
      const cargador = new THREE.TextureLoader();  
      cargador.load("x.webp", textura => {  
        textura.mapping = THREE.EquirectangularReflectionMapping;  
        textura.colorSpace = THREE.SRGBColorSpace;  
        textura.minFilter = THREE.LinearFilter;  
        textura.magFilter = THREE.LinearFilter;  
        escena.background = textura;  
      });  

      // Cámara  
      camara3d = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);  
      camara3d.position.set(0, 1.5, suavizadoZoom);  

      // Renderizador  
      renderizador = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas3d'), antialias: true });  
      renderizador.setSize(window.innerWidth, window.innerHeight);  
      renderizador.shadowMap.enabled = true;  
      renderizador.shadowMap.type = THREE.PCFSoftShadowMap;  
      renderizador.setFrustumCulled = true; // activa culling por frustum  

      // Luces  
      const luzSol = new THREE.DirectionalLight(0xffffff, 1.1);  
      luzSol.position.set(10, 20, 10);  
      luzSol.castShadow = true;  
      escena.add(luzSol);  
      escena.add(new THREE.AmbientLight(0xffffff, 0.6));  

      // Cubo  
      const geoCubo = new THREE.BoxGeometry(1.0, 1.0, 1.0);  
      const matCubo = new THREE.MeshStandardMaterial({  
        color: 0x448aff,  
        metalness: 0.2,  
        roughness: 0.3,  
        side: THREE.FrontSide // solo caras visibles  
      });  
      cubo = new THREE.Mesh(geoCubo, matCubo);  
      cubo.castShadow = true;  
      cubo.frustumCulled = true;  
      escena.add(cubo);  

      // Piso optimizado  
      cargador.load("piso.webp", textura => {  
        textura.wrapS = textura.wrapT = THREE.RepeatWrapping;  
        textura.repeat.set(20, 20);  

        const geoPiso = new THREE.PlaneGeometry(10, 10);  
        const matPiso = new THREE.MeshStandardMaterial({  
          map: textura,  
          roughness: 1,  
          metalness: 0,  
          side: THREE.FrontSide  
        });  
        const piso = new THREE.Mesh(geoPiso, matPiso);  
        piso.rotation.x = -Math.PI / 2;  
        piso.position.y = -1.2;  
        piso.receiveShadow = true;  
        piso.frustumCulled = true;  
        escena.add(piso);  
      });  

      escena.fog = new THREE.Fog(0xaee1f9, 15, 80);  

      window.addEventListener('resize', () => {  
        camara3d.aspect = window.innerWidth / window.innerHeight;  
        camara3d.updateProjectionMatrix();  
        renderizador.setSize(window.innerWidth, window.innerHeight);  
      });  

      animar();  
    }  

    function animar() {  
      requestAnimationFrame(animar);  

      // suavizado  
      suavizadoX += (objetivoX - suavizadoX) * 0.09;  
      suavizadoY += (objetivoY - suavizadoY) * 0.09;  
      suavizadoZoom += (objetivoZoom - suavizadoZoom) * 0.08;  

      const radio = suavizadoZoom;  
      const y = Math.max(0.8, radio * Math.sin(suavizadoX) + 1.2);  
      const x = radio * Math.sin(suavizadoY) * Math.cos(suavizadoX);  
      const z = radio * Math.cos(suavizadoY) * Math.cos(suavizadoX);  

      camara3d.position.set(x, y, z);  
      camara3d.lookAt(0, 0, 0);  

      renderizador.render(escena, camara3d);  
    }  

    function distancia(a, b) {  
      return Math.hypot(a.x - b.x, a.y - b.y);  
    }  

    const manos = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });  
    manos.setOptions({  
      maxNumHands: 2,  
      modelComplexity: 0,  
      selfieMode: true,  
      minDetectionConfidence: 0.5,  
      minTrackingConfidence: 0.5  
    });  

    manos.onResults(resultado => {  
      ctx.clearRect(0, 0, canvas.width, canvas.height);  
      ctx.drawImage(resultado.image, 0, 0, canvas.width, canvas.height);  

      if (!resultado.multiHandLandmarks) return;  

      resultado.multiHandLandmarks.forEach((puntos, i) => {  
        const muñeca = puntos[0];  
        const pulgar = puntos[4];  
        const indice = puntos[8];  
        const mano = resultado.multiHandedness[i].label.toLowerCase();  

        if (mano === "left") {  
          if (manoIzquierdaPrev) {  
            const dx = (muñeca.x - manoIzquierdaPrev.x);  
            const dy = (muñeca.y - manoIzquierdaPrev.y);  
            objetivoY -= dx * 3;  
            objetivoX -= dy * 3;  
            objetivoX = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, objetivoX));  
          }  
          manoIzquierdaPrev = { x: muñeca.x, y: muñeca.y };  
        }  

        if (mano === "right") {  
          const d = distancia(pulgar, indice);  
          const min = 0.02, max = 0.2;  
          const normalizado = Math.min(Math.max((d - min) / (max - min), 0), 1);  
          objetivoZoom = 5 - normalizado * 3;  
        }  
      });  
    });  

    const camara = new Camera(video, {  
      onFrame: async () => await manos.send({ image: video }),  
      width: 640, height: 480  
    });  
    camara.start();  

    iniciarEscena();  
  </script>  
</body>  
</html>
